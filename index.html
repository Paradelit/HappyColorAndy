<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Para Andy</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ffffff">
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
        body { margin: 0; background: #f0f4f8; font-family: sans-serif; height: 100dvh; width: 100vw; overflow: hidden; display: flex; flex-direction: column; user-select: none; -webkit-user-select: none; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; background: #f0f4f8; transition: transform 0.3s ease; z-index: 10; }
        .hidden { display: none !important; }

        /* GALER√çA */
        #gallery-screen { z-index: 20; overflow-y: auto; }
        .gallery-content { padding: 20px; max-width: 600px; margin: 0 auto; }
        .gallery-header-block { text-align: center; margin: 30px 0 20px 0; }
        .gallery-title { color: #d63384; font-size: 1.8rem; margin: 0; }
        .gallery-subtitle { color: #666; font-size: 0.9rem; margin-top: 5px; }
        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 20px; }
        .gallery-item { background: white; border-radius: 15px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.1); position: relative; }
        .thumb-preview { width: 100%; height: 160px; object-fit: contain; background: white; padding: 10px; box-sizing: border-box; }
        .check-badge { position: absolute; top: 10px; right: 10px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; justify-content: center; align-items: center; font-size: 14px; }
        .thumb-title { padding: 15px; font-weight: bold; color: #444; text-align: center; }

        /* JUEGO */
        header { flex: 0 0 50px; background: white; display: flex; align-items: center; justify-content: space-between; padding: 0 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); z-index: 500; }
        h1 { color: #d63384; font-size: 1rem; margin: 0 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; text-align: center; }
        .header-btns { display: flex; gap: 8px; }
        button.icon-btn { background: #eee; border: none; border-radius: 50%; width: 35px; height: 35px; font-size: 18px; display: flex; justify-content: center; align-items: center; }
        button.icon-btn:active { background: #d63384; color: white; }
        #btn-hint { background: #fff3cd; color: #856404; display: none; }
        #btn-hint.active { display: flex; animation: popIn 0.3s; }

        #progress-container { width: 100%; height: 4px; background: #e0e0e0; position: relative; z-index: 450; }
        #progress-bar { height: 100%; background: #d63384; width: 0%; transition: width 0.3s ease; }

        /* VIEWPORT OPTIMIZADO */
        #viewport { flex-grow: 1; position: relative; overflow: hidden; background: #e0e0e0; width: 100%; z-index: 1; }
        
        #zoom-layer { 
            position: absolute; top: 0; left: 0; 
            transform-origin: 0 0; 
            box-shadow: 0 0 20px rgba(0,0,0,0.2); 
            will-change: transform; /* Aceleraci√≥n GPU */
        }
        
        #shake-layer { position: relative; width: 100%; height: 100%; }

        /* ARQUITECTURA S√ÅNDWICH */
        /* 1. Capa de Pintura (Canvas): Baja resoluci√≥n, estirada para cubrir todo */
        #lienzo { 
            display: block; 
            width: 100%; height: 100%; /* Se estira CSS */
            image-rendering: pixelated; /* Evita borrosidad al estirar */
        }

        /* 2. Capa de L√≠neas (Imagen HD): Se pone encima */
        #lines-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* Los clicks atraviesan esta capa */
            mix-blend-mode: multiply; /* EL TRUCO: Blanco transparente, Negro opaco */
            display: block;
        }

        .paleta-container { flex: 0 0 auto; background: white; width: 100%; display: flex; align-items: center; box-shadow: 0 -4px 10px rgba(0,0,0,0.05); z-index: 1000; overflow-x: auto; padding: 10px 0 25px 0; }
        .paleta { display: flex; gap: 12px; padding: 0 15px; min-width: max-content; }
        .color-btn { width: 50px; height: 50px; border-radius: 50%; border: 3px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.2); position: relative; flex-shrink: 0; }
        .color-number { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold; font-size: 18px; text-shadow: 0 1px 2px rgba(0,0,0,0.8); pointer-events: none; }
        .color-btn.light .color-number { color: #333; text-shadow: none; }
        .selected { border-color: #333; transform: scale(1.1); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }

        .shake { animation: shake 0.3s; }
        @keyframes shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-5px, 0); } 75% { transform: translate(5px, 0); } }
        @keyframes popIn { from {transform: scale(0);} to {transform: scale(1);} }

        #victory-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; display: flex; justify-content: center; align-items: center; }
        .victory-content { background: white; padding: 30px; border-radius: 20px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2); animation: popIn 0.5s; }
        .victory-btn { background: #d63384; color: white; border: none; padding: 10px 25px; font-size: 1rem; border-radius: 25px; margin-top: 15px; }
        
        #loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 2000; display: flex; justify-content: center; align-items: center; font-weight: bold; color: #666; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="gallery-screen" class="screen">
        <div class="gallery-content">
            <div class="gallery-header-block">
                <h1 class="gallery-title">üé® Recuerdos</h1>
                <div class="gallery-subtitle" id="gallery-counter">Cargando...</div>
            </div>
            <div class="gallery-grid" id="gallery-grid"></div>
        </div>
    </div>

    <div id="game-screen" class="screen hidden">
        <header>
            <button id="btn-back" class="icon-btn">‚¨ÖÔ∏è</button>
            <h1>Foto</h1>
            <div class="header-btns">
                <button id="btn-hint" class="icon-btn">üí°</button>
                <button id="btn-download" class="icon-btn">üíæ</button>
                <button id="btn-reset" class="icon-btn">üóëÔ∏è</button>
                <button id="btn-solucion" class="icon-btn">üëÅÔ∏è</button>
            </div>
        </header>
        <div id="progress-container"><div id="progress-bar"></div></div>
        
        <div id="viewport">
            <div id="loading-overlay" class="hidden">Preparando lienzo...</div>
            <div id="zoom-layer">
                <div id="shake-layer">
                    <canvas id="lienzo"></canvas>
                    <img id="lines-overlay" src="" alt="">
                </div>
            </div>
        </div>

        <div class="paleta-container">
            <div class="paleta" id="paleta"></div>
        </div>
    </div>

    <div id="victory-modal" class="hidden">
        <div class="victory-content">
            <h2>¬°Felicidades! üéâ</h2>
            <p>Has completado este recuerdo.</p>
            <button class="victory-btn" onclick="document.getElementById('victory-modal').classList.add('hidden')">¬°Genial!</button>
        </div>
    </div>

    <script>
        // CONFIGURACI√ìN (TUS COLORES)
        const niveles = [
            {
                id: 'foto1',
                nombre: 'Recuerdo 1',
                lineas: 'lineas1.png', 
                solucion: 'solucion1.png',
                colores: [
                    '#953e38', '#551813', '#76231b', '#150c0a', '#2c1a14', '#644034', '#58372a', '#4e3024', '#482b1f', '#3f261b', 
                    '#301e16', '#382218', '#975f3d', '#26180f', '#19100a', '#1f130b', '#e4aa80', '#af7449', '#bf8960', '#754a29', 
                    '#653e20', '#eebb92', '#845631', '#cd996c', '#c0814a', '#db9d65', '#9f6d3f', '#cd9056', '#eab37c', '#291e13', 
                    '#ae8050', '#e1a86c', '#f0c088', '#201b15', '#19150f', '#3d321f', '#463c25', '#928360', '#aa9e7f', '#beb292', 
                    '#c8bc9b', '#a59978', '#c5b894', '#b0a585', '#817552', '#0b0a07', '#cdc29d', '#6a603e', '#312c1b', '#a29a7d', 
                    '#29261b', '#b7ae8d', '#1b1911', '#9d9575', '#999171', '#948c6c', '#19170f', '#5c5538', '#4e482f', '#d2caa8', 
                    '#211f15', '#242216', '#afab93', '#6f6b52', '#827e64', '#252419', '#898870', '#737564', '#f6f9e7', '#202316', 
                    '#0b0d0a', '#dde8db', '#c1d2d0', '#07090b', '#333c47', '#24282d', '#32588c', '#003d96', '#141619', '#101215', 
                    '#0e49a4', '#1e56b2', '#212429', '#2d333d', '#1e2126', '#023385', '#4074cc', '#282c33', '#002a74', '#2f63c0', 
                    '#243463', '#0f1d47', '#101732', '#1b1b1f', '#ffffff', '#000000', '#0e2256'
                ]
            },
            {
                id: 'foto2',
                nombre: 'Recuerdo 2',
                lineas: 'lineas2.png',
                solucion: 'solucion2.png',
                colores: [
                    '#e8aba9', '#671a16', '#b62115', '#961b10', '#df3b25', '#321d1a', '#583e3a', '#f1baad', '#492f27', '#372722', 
                    '#5f453b', '#a47765', '#927c73', '#ad7f6b', '#654b3e', '#886e61', '#b98f79', '#c7987f', '#705242', '#6a4f3f', 
                    '#82624f', '#7c5b47', '#755744', '#ecccb7', '#8a664d', '#846047', '#d4a481', '#916c51', '#967256', '#eab891', 
                    '#deaf89', '#99704e', '#9e7756', '#ae8664', '#a47d5b', '#c7b39f', '#f1d3b4', '#d7cdbd', '#f4dfb5', '#f6ebbf', 
                    '#f6f2cf', '#97966e', '#e6e6c9', '#838362', '#737552', '#65674c', '#d9dcc5', '#697362', '#c5cac3', '#525e4f', 
                    '#606962', '#465249', '#cfdcd3', '#3c4a47', '#c7d5d4', '#bdcfd5', '#b3c6d2', '#adb9c4', '#667f97', '#a0adba', 
                    '#a1b6cf', '#576c87', '#57595c', '#9ba2ad', '#82878f', '#42577a', '#384b6d', '#9095a1', '#2d3855', '#1f1e30', 
                    '#161221', '#4d3d6c', '#564379', '#574770', '#604b80', '#6b5187', '#4d3e5c', '#755a8e', '#8b6fa2', '#836899', 
                    '#53495b', '#7c5f93', '#9d82b0', '#9b7fae', '#977ca9', '#9577a9', '#a688b6', '#675471', '#927690', '#7d727c', 
                    '#766071', '#4e3e47', '#b4596d', '#c3667a', '#654d52', '#9f5665', '#c87684', '#d28791', '#271617', '#de9a9c'
                ]
            }
        ];

        // DB SETUP
        const DB_NAME = 'HappyAndyDB'; const DB_VERSION = 1; let db;
        function initDB() { return new Promise(r => { const req = indexedDB.open(DB_NAME, DB_VERSION); req.onupgradeneeded = e => { db = e.target.result; if(!db.objectStoreNames.contains('saves')) db.createObjectStore('saves', { keyPath: 'id' }); }; req.onsuccess = e => { db = e.target.result; r(db); }; req.onerror = () => r(null); }); }
        function saveToDB(id, data) { if(!db) return; const tx = db.transaction('saves', 'readwrite'); tx.objectStore('saves').put({ id: id, data: data }); }
        function loadFromDB(id) { return new Promise(r => { if(!db) return r(null); const tx = db.transaction('saves', 'readonly'); const req = tx.objectStore('saves').get(id); req.onsuccess = () => r(req.result ? req.result.data : null); req.onerror = () => r(null); }); }
        function deleteFromDB(id) { if(!db) return; const tx = db.transaction('saves', 'readwrite'); tx.objectStore('saves').delete(id); }

        // VARS GLOBALES
        const canvas = document.getElementById('lienzo');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const linesOverlay = document.getElementById('lines-overlay');
        const zoomLayer = document.getElementById('zoom-layer');
        const shakeLayer = document.getElementById('shake-layer');
        const loadingOverlay = document.getElementById('loading-overlay');
        const btnHint = document.getElementById('btn-hint');
        const progressBar = document.getElementById('progress-bar');
        
        let currentLevel = null, coloresRGB = [], selectedColorIndex = 0;
        let scale = 1, pX = 0, pY = 0;
        let logicWidth = 0, logicHeight = 0; // Dimensiones optimizadas
        
        // Memoria para c√°lculos
        let solutionData = null; // Uint8ClampedArray con la soluci√≥n (escalada)
        let wallMap = null;      // Uint8Array con los muros (0 o 1)
        let totalPixels = 0;

        initDB().then(renderGallery);

        // GALER√çA
        async function renderGallery() {
            const grid = document.getElementById('gallery-grid');
            grid.innerHTML = '';
            let completed = 0;
            for(let i=0; i<niveles.length; i++) {
                const n = niveles[i];
                const el = document.createElement('div');
                el.className = 'gallery-item';
                const saved = await loadFromDB(n.id);
                // Si hay save, usamos el save como preview (aunque sea low res, se ve peque√±o)
                // Si no, la linea original
                const src = saved ? saved : n.lineas;
                const isDone = localStorage.getItem('done_'+n.id) === 'true';
                if(isDone) completed++;
                el.innerHTML = `<img src="${src}" class="thumb-preview">${isDone?'<div class="check-badge">‚úì</div>':''}<div class="thumb-title">${n.nombre}</div>`;
                el.onclick = () => loadLevel(i);
                grid.appendChild(el);
            }
            document.getElementById('gallery-counter').innerText = `Completados: ${completed}/${niveles.length}`;
        }

        // CARGA INTELIGENTE
        function loadLevel(idx) {
            currentLevel = niveles[idx];
            document.querySelector('header h1').innerText = currentLevel.nombre;
            document.getElementById('gallery-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            loadingOverlay.classList.remove('hidden');
            
            // Generar paleta
            const paletaDiv = document.getElementById('paleta');
            paletaDiv.innerHTML = '';
            coloresRGB = currentLevel.colores.map((hex, i) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                btn.style.backgroundColor = hex;
                const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
                if((r*0.299+g*0.587+b*0.114)>186) btn.classList.add('light');
                btn.innerHTML = `<span class="color-number">${i+1}</span>`;
                if(i===0) { btn.classList.add('selected'); selectedColorIndex = 0; }
                const act = (e) => { e.preventDefault(); e.stopPropagation(); document.querySelectorAll('.color-btn').forEach(b=>b.classList.remove('selected')); btn.classList.add('selected'); selectedColorIndex = i; };
                btn.addEventListener('touchstart', act, {passive:false});
                btn.onclick = act;
                paletaDiv.appendChild(btn);
                return {r, g, b};
            });

            // Iniciar proceso de carga as√≠ncrono para no bloquear UI
            setTimeout(initGameLogic, 100);
        }

        async function initGameLogic() {
            // 1. Cargar im√°genes originales
            const imgL = await loadImage(currentLevel.lineas);
            const imgS = await loadImage(currentLevel.solucion);

            // 2. Configurar visualizaci√≥n HD (Capa Superior)
            // La imagen se ve tal cual, gigante y n√≠tida
            linesOverlay.src = currentLevel.lineas;
            
            // 3. Configurar L√≥gica Optimizada (Capa Inferior)
            // Reducimos la resoluci√≥n de c√°lculo a algo manejable (ej. max 1000px)
            // Esto hace que el relleno sea instant√°neo
            const MAX_LOGIC_DIM = 1000;
            let w = imgL.width, h = imgL.height;
            let ratio = 1;
            
            if(w > MAX_LOGIC_DIM || h > MAX_LOGIC_DIM) {
                const r = w / h;
                if(w > h) { w = MAX_LOGIC_DIM; h = MAX_LOGIC_DIM / r; }
                else { h = MAX_LOGIC_DIM; w = MAX_LOGIC_DIM * r; }
                ratio = imgL.width / w; // Cu√°nto hemos reducido
            } else {
                w = imgL.width; h = imgL.height;
            }
            w = Math.floor(w); h = Math.floor(h);
            logicWidth = w; logicHeight = h;

            // Configurar Canvas de Pintura (Low Res)
            canvas.width = w; canvas.height = h;
            
            // Ajustar tama√±o visual del contenedor para que coincida con la imagen HD
            zoomLayer.style.width = imgL.width + 'px';
            zoomLayer.style.height = imgL.height + 'px';
            
            // El canvas se estira para ocupar todo el zoomLayer
            // La imagen overlay tambi√©n ocupa todo el zoomLayer

            // 4. Pre-calcular datos en memoria (Offscreen)
            const offCanvas = document.createElement('canvas');
            offCanvas.width = w; offCanvas.height = h;
            const offCtx = offCanvas.getContext('2d', {willReadFrequently: true});

            // Leer Soluci√≥n Reducida
            offCtx.drawImage(imgS, 0, 0, w, h);
            solutionData = offCtx.getImageData(0, 0, w, h).data;

            // Leer Paredes Reducidas
            offCtx.drawImage(imgL, 0, 0, w, h);
            const wallData = offCtx.getImageData(0, 0, w, h).data;
            
            // Crear mapa de muros (0 = libre, 1 = muro)
            wallMap = new Uint8Array(w * h);
            totalPixels = 0;
            for(let i=0; i<wallData.length; i+=4) {
                // Si es oscuro, es muro
                if(wallData[i] < 180 && wallData[i+1] < 180 && wallData[i+2] < 180 && wallData[i+3] > 200) {
                    wallMap[i/4] = 1;
                } else {
                    wallMap[i/4] = 0;
                    // Solo contamos p√≠xeles que tienen soluci√≥n (no transparentes)
                    if(solutionData[i+3] > 0) totalPixels++;
                }
            }

            // 5. Cargar progreso guardado
            const savedBase64 = await loadFromDB(currentLevel.id);
            if(savedBase64) {
                const savedImg = await loadImage(savedBase64);
                ctx.drawImage(savedImg, 0, 0, w, h); // Pintar en canvas low res
            } else {
                // Pintar fondo blanco base para que el multiply funcione bien
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0,0,w,h);
            }

            // 6. Resetear Zoom
            const vpW = document.getElementById('viewport').clientWidth;
            const vpH = document.getElementById('viewport').clientHeight;
            const scaleStart = Math.min(vpW/imgL.width, vpH/imgL.height) * 0.9;
            scale = scaleStart;
            pX = (vpW - imgL.width*scale)/2; 
            pY = (vpH - imgL.height*scale)/2;
            updateTransform();

            updateProgress();
            loadingOverlay.classList.add('hidden');
        }

        function loadImage(src) {
            return new Promise(r => { const i = new Image(); i.onload = () => r(i); i.src = src; });
        }

        // INPUT & ZOOM (Mapeo de coordenadas HD -> SD)
        function handleInput(screenX, screenY) {
            const rect = document.getElementById('viewport').getBoundingClientRect();
            // Coordenada en el espacio de la imagen HD
            const hdX = (screenX - rect.left - pX) / scale;
            const hdY = (screenY - rect.top - pY) / scale;

            // Convertir a coordenada L√≥gica (SD)
            // Ratio = logicWidth / originalWidth
            const ratioX = logicWidth / zoomLayer.clientWidth; // zoomLayer tiene width del original
            const ratioY = logicHeight / zoomLayer.clientHeight; // pero lo leemos del style setead

            // Ojo: zoomLayer.style.width tiene el tama√±o original.
            // Simplemente hacemos regla de 3
            const originalW = parseFloat(zoomLayer.style.width);
            const originalH = parseFloat(zoomLayer.style.height);
            
            if(hdX >= 0 && hdX < originalW && hdY >= 0 && hdY < originalH) {
                const lx = Math.floor(hdX * (logicWidth / originalW));
                const ly = Math.floor(hdY * (logicHeight / originalH));
                paintLogic(lx, ly);
            }
        }

        function paintLogic(x, y) {
            const idx = (y * logicWidth + x) * 4;
            // Check Muro o Vac√≠o
            if(wallMap[y*logicWidth + x] === 1 || solutionData[idx+3] === 0) return;

            // Check Color Correcto
            let best = -1, minD = 999;
            const r = solutionData[idx], g = solutionData[idx+1], b = solutionData[idx+2];
            coloresRGB.forEach((c, i) => {
                const d = Math.abs(r-c.r) + Math.abs(g-c.g) + Math.abs(b-c.b);
                if(d < minD) { minD = d; best = i; }
            });

            if(best === selectedColorIndex) {
                floodFill(x, y, coloresRGB[best]);
                saveToDB(currentLevel.id, canvas.toDataURL());
                updateProgress();
            } else {
                navigator.vibrate?.(200);
                shakeLayer.classList.add('shake');
                setTimeout(()=>shakeLayer.classList.remove('shake'), 300);
            }
        }

        function floodFill(sx, sy, col) {
            const w = logicWidth, h = logicHeight;
            const vis = ctx.getImageData(0,0,w,h);
            const dat = vis.data;
            const stack = [[sx, sy]];
            const tr = col.r, tg = col.g, tb = col.b;
            
            // Para evitar bucles infinitos, marcamos visitados en un array simple
            // Pero como pintamos directamente en 'dat', podemos usar el color como marca
            // Ojo: si repintamos el mismo color, bucle. Usamos set auxiliar.
            const seen = new Uint8Array(w*h);

            while(stack.length) {
                const [cx, cy] = stack.pop();
                const idx = cy*w + cx;
                if(seen[idx]) continue;
                
                // Check Muro
                if(wallMap[idx] === 1) continue;

                // Check Soluci√≥n (Tolerancia estricta)
                const i = idx*4;
                // Si coincide con la soluci√≥n del pixel inicial
                // (Usamos la soluci√≥n del punto de toque como referencia, 
                // pero aqu√≠ simplificamos comparando con el color objetivo porque el usuario acert√≥)
                const sr=solutionData[i], sg=solutionData[i+1], sb=solutionData[i+2];
                
                // ¬øEs este pixel parte de la zona del color correcto?
                // Comparamos con el color que intentamos pintar (que sabemos que es el correcto de la zona)
                if(Math.abs(sr-tr)<=10 && Math.abs(sg-tg)<=10 && Math.abs(sb-tb)<=10) {
                    dat[i] = tr; dat[i+1] = tg; dat[i+2] = tb; dat[i+3] = 255;
                    seen[idx] = 1;
                    
                    if(cx+1<w) stack.push([cx+1, cy]);
                    if(cx-1>=0) stack.push([cx-1, cy]);
                    if(cy+1<h) stack.push([cx, cy+1]);
                    if(cy-1>=0) stack.push([cx, cy-1]);
                }
            }
            ctx.putImageData(vis, 0, 0);
        }

        // AYUDAS Y PROGRESO
        function updateProgress() {
            // Muestreo r√°pido (1 de cada 20 pixeles)
            const w = logicWidth, h = logicHeight;
            const cur = ctx.getImageData(0,0,w,h).data;
            let painted = 0;
            let totalSample = 0;
            const step = 20;

            for(let i=0; i<solutionData.length; i+=4*step) {
                // Si no es muro y tiene soluci√≥n
                if(wallMap[i/4] === 0 && solutionData[i+3]>0) {
                    totalSample++;
                    // Si el color actual se parece al de la soluci√≥n
                    if(Math.abs(cur[i]-solutionData[i])<5 && Math.abs(cur[i+1]-solutionData[i+1])<5) {
                        painted++;
                    }
                }
            }
            const pct = (painted / totalSample) * 100;
            progressBar.style.width = pct + '%';

            if(pct > 95) { btnHint.innerText = "‚ú®"; btnHint.classList.add('active'); }
            else if(pct > 90) { btnHint.innerText = "üí°"; btnHint.classList.add('active'); }
            else btnHint.classList.remove('active');

            if(pct > 99.5 && !localStorage.getItem('done_'+currentLevel.id)) {
                localStorage.setItem('done_'+currentLevel.id, 'true');
                confetti({particleCount:150, spread:70, origin:{y:0.6}});
                setTimeout(()=>document.getElementById('victory-modal').classList.remove('hidden'), 1000);
            }
        }

        btnHint.onclick = () => {
            const w = logicWidth, h = logicHeight;
            const pct = parseFloat(progressBar.style.width);
            
            if(pct > 95) {
                // VARITA: Pintar todo lo que falta
                const imgData = ctx.getImageData(0,0,w,h);
                const d = imgData.data;
                for(let i=0; i<d.length; i+=4) {
                    if(wallMap[i/4]===0 && solutionData[i+3]>0) {
                        d[i]=solutionData[i]; d[i+1]=solutionData[i+1]; d[i+2]=solutionData[i+2]; d[i+3]=255;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToDB(currentLevel.id, canvas.toDataURL());
                updateProgress();
            } else {
                // BOMBILLA: Buscar zona vac√≠a
                const cur = ctx.getImageData(0,0,w,h).data;
                const step = 4*5; // saltos peque√±os
                for(let i=0; i<cur.length; i+=step) {
                    if(wallMap[i/4]===0 && solutionData[i+3]>0) {
                        // Si est√° sin pintar (diferente a solucion)
                        if(Math.abs(cur[i]-solutionData[i])>10) {
                            // Encontramos un pixel sin pintar. Identificar color y floodfill
                            let best = -1, minD = 999;
                            coloresRGB.forEach((c, idx) => {
                                const d = Math.abs(solutionData[i]-c.r) + Math.abs(solutionData[i+1]-c.g) + Math.abs(solutionData[i+2]-c.b);
                                if(d < minD) { minD=d; best=idx; }
                            });
                            
                            if(best !== -1) {
                                const pixIdx = i/4;
                                floodFill(pixIdx%w, Math.floor(pixIdx/w), coloresRGB[best]);
                                saveToDB(currentLevel.id, canvas.toDataURL());
                                updateProgress();
                                // Centrar
                                const originalW = parseFloat(zoomLayer.style.width);
                                const originalH = parseFloat(zoomLayer.style.height);
                                const hdX = (pixIdx%w) * (originalW/w);
                                const hdY = Math.floor(pixIdx/w) * (originalH/h);
                                const vpW = document.getElementById('viewport').clientWidth;
                                const vpH = document.getElementById('viewport').clientHeight;
                                pX = (vpW/2) - (hdX*scale);
                                pY = (vpH/2) - (hdY*scale);
                                updateTransform();
                            }
                            break;
                        }
                    }
                }
            }
        };

        // EVENTOS TOUCH & ZOOM
        let isDrag=false, isPinch=false, hasMov=false, lX=0, lY=0, initDist=0, lZoomT=0;
        viewport.addEventListener('touchstart', e => {
            if(e.target.closest('.paleta-container')) return;
            if(e.touches.length===1) { isDrag=true; hasMov=false; lX=e.touches[0].clientX; lY=e.touches[0].clientY; }
            else if(e.touches.length===2) { isDrag=false; isPinch=true; initDist=getDist(e.touches[0], e.touches[1]); lZoomT=Date.now(); }
        }, {passive:false});
        viewport.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length===2) lZoomT=Date.now();
            if(isDrag && e.touches.length===1) {
                const dx=e.touches[0].clientX-lX, dy=e.touches[0].clientY-lY;
                if(Math.abs(dx)>2||Math.abs(dy)>2) hasMov=true;
                pX+=dx; pY+=dy; lX=e.touches[0].clientX; lY=e.touches[0].clientY; updateTransform();
            } else if(isPinch && e.touches.length===2) {
                const dist=getDist(e.touches[0], e.touches[1]);
                const midX=(e.touches[0].clientX+e.touches[1].clientX)/2, midY=(e.touches[0].clientY+e.touches[1].clientY)/2;
                const ns = Math.min(Math.max(0.1, scale*(dist/initDist)), 12);
                pX = midX - (midX - pX) * (ns/scale); pY = midY - (midY - pY) * (ns/scale);
                scale=ns; initDist=dist; updateTransform();
            }
        }, {passive:false});
        viewport.addEventListener('touchend', e => {
            isDrag=false; isPinch=false;
            if(Date.now()-lZoomT<400) return;
            if(e.changedTouches.length===1 && !hasMov) handleInput(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        });
        function getDist(t1, t2) { return Math.hypot(t1.clientX-t2.clientX, t1.clientY-t2.clientY); }
        function updateTransform() { zoomLayer.style.transform = `translate(${pX}px, ${pY}px) scale(${scale})`; }

        // Botones extra
        document.getElementById('btn-back').onclick = () => { gameScreen.classList.add('hidden'); document.getElementById('gallery-screen').classList.remove('hidden'); renderGallery(); };
        document.getElementById('btn-reset').onclick = () => { if(confirm('¬øReiniciar?')) { deleteFromDB(currentLevel.id); localStorage.removeItem('done_'+currentLevel.id); ctx.fillStyle='#fff'; ctx.fillRect(0,0,logicWidth,logicHeight); updateProgress(); } };
        document.getElementById('btn-download').onclick = () => { 
            // Componer imagen final HD para descargar
            const finalC = document.createElement('canvas');
            finalC.width = logicWidth; finalC.height = logicHeight;
            const fCtx = finalC.getContext('2d');
            fCtx.drawImage(canvas, 0, 0); // Pintura
            fCtx.globalCompositeOperation = 'multiply';
            fCtx.drawImage(document.getElementById('lines-overlay'), 0, 0, logicWidth, logicHeight); // Lineas
            const link = document.createElement('a');
            link.download = 'Recuerdo.png';
            link.href = finalC.toDataURL();
            link.click();
        };
        const btnSol = document.getElementById('btn-solucion');
        btnSol.onmousedown = btnSol.ontouchstart = (e) => { e.preventDefault(); linesOverlay.style.opacity=0; canvas.style.opacity=0; zoomLayer.style.backgroundImage=`url('${currentLevel.solucion}')`; zoomLayer.style.backgroundSize='100% 100%'; };
        btnSol.onmouseup = btnSol.ontouchend = () => { linesOverlay.style.opacity=1; canvas.style.opacity=1; zoomLayer.style.backgroundImage='none'; };

    </script>
</body>
</html>
